from pymongo import MongoClient
import bson.json_util
import pika
import arrow
import os
import importlib
import sys
import threading
import time

TEST_DIR = os.path.abspath(os.path.dirname(__file__))
PARENT_DIR = os.path.join(TEST_DIR, '..')
sys.path.insert(0, PARENT_DIR)

db = MongoClient("mongodb://mongo:27017/monitor")
db = db.monitor

max_thread = $MAX_THREAD
current_thread = 0

class myThread(threading.Thread):
	def __init__(self, document=None):
		assert document is not None, "document is not defined."

		threading.Thread.__init__(self)
		self.document = document
	#end def

	def run(self):
		global current_thread
		assert self.document is not None, "document is not defined."
		
		_hash = self.document["hash"]
		db.queue.update(
			{"hash":_hash},
			{"$set":{
				"status":"processing", 
				"last_update":arrow.utcnow().datetime
			}}
		)
		print("Processing: {}".format(self.document["link"].encode("utf-8")))

		# run the crawler
		crawler = importlib.import_module(
			"crawlers.{}".format(_hash)
		)
		try:
			crawler = crawler.Crawler()
			crawler.crawl()
		except exceptions.NoThreadLink as no_thread_link:
			db.log.insert_one({
				"created_date":arrow.utcnow().datetime,
				"type":"ERROR",
				"message": no_thread_link.value,
				"exception": "exceptions.NoThreadLink",
				"crawler":crawler.get_engine_info()
			})
		#end try

		db.queue.update(
			{"hash":_hash},
			{"$set":{
				"status":"idle",
				"last_completed":arrow.utcnow().datetime,
				"last_update":arrow.utcnow().datetime
			}}
		)
		current_thread = current_thread - 1
	#end def
#end def

def callback(ch, method, properties, body):
	global current_thread

	message_sent = False
	is_in_hold = False

	while not message_sent:
		# hold the message in hand
		# later dump it to thread
		if not is_in_hold:
			document = bson.json_util.loads(str(body,"utf-8"))
			ch.basic_ack(delivery_tag = method.delivery_tag)
			is_in_hold = True
		#end if

		if current_thread < max_thread:
			is_in_hold = False
			message_sent = True
			current_thread = current_thread + 1
			t = myThread(document=document)
			t.start()
		#end if
	#end while
#end def

while(True):
	try:
		connection = pika.BlockingConnection(pika.ConnectionParameters(host='rabbitmq'))
		channel = connection.channel()
		channel.queue_declare(queue='crawlers', durable=True)
		channel.basic_qos(prefetch_count=1)
		channel.basic_consume(callback, queue='crawlers')
		channel.start_consuming()
	except pika.exceptions.ConnectionClosed as connectionClosed:
		print("Reconnecting to RabbitMQ Server...")
	#end try
#end while